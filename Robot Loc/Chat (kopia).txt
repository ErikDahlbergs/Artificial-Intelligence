import numpy as np

def localize(sensor, new_x, new_y, new_h, reading_x, reading_y, x_est, y_est, x_err, y_err, prior):
    """
    This function implements a robot localization algorithm based on probabilistic reasoning.

    Parameters:
        sensor (bool): True if a sensor reading was found, False otherwise.
        new_x (int): The new true x position of the robot.
        new_y (int): The new true y position of the robot.
        new_h (int): The new true direction of the robot (0-3, representing N, E, S, W).
        reading_x (int or str): The current sensor reading for the x coordinate, or "nothing".
        reading_y (int or str): The current sensor reading for the y coordinate, or "nothing".
        x_est (int): The current estimated x position of the robot.
        y_est (int): The current estimated y position of the robot.
        x_err (int): The error made in the estimation of the x position.
        y_err (int): The error made in the estimation of the y position.
        prior (ndarray): The prior probability distribution over the possible robot positions.

    Returns:
        posterior (ndarray): The posterior probability distribution over the possible robot positions.
    """

    # Define the transition matrix T. This matrix encodes the probability of moving
    # from one state (position and direction) to another. It is a 4D matrix, where
    # the first two dimensions represent the current position, and the second two
    # dimensions represent the next position.
    T = np.zeros((20, 20, 4, 4))

    for i in range(20):
        for j in range(20):
            for h in range(4):
                # If the robot hits a wall, the probability of transitioning to a
                # new direction is zero. Otherwise, there is a 30% chance of changing
                # direction, and a 70% chance of staying in the same direction.
                if i == 0 or i == 19 or j == 0 or j == 19:
                    T[i, j, h, h] = 1.0
                else:
                    T[i, j, h, h] = 0.7
                    T[i, j, h, (h + 1) % 4] = 0.15
                    T[i, j, h, (h - 1) % 4] = 0.15

    # Define the sensor model Z. This is a 20x20x4 matrix, where each element
    # represents the probability of obtaining a sensor reading given the robot's
    # true position and direction. If the sensor reading is "nothing", the
    # probability is set to 1.0 for all positions and directions.
    Z = np.zeros((20, 20, 4))

    if sensor:
        for i in range(20):
            for j in range(20):
                for h in range(4):
                    # Compute the probability of obtaining the sensor reading given the
                    # current position and direction. This is done by comparing the
                    # sensor reading to the true position and direction of the robot,
                    # and computing a Gaussian distribution over the distance between
                    # the true and estimated positions.
                    if reading_x != "nothing" and reading_y != "nothing":
                        dist = np.sqrt((i - reading_x)**2 + (j - reading_y)**2)
                        prob = np.exp(-(dist**2
                        /(2 * x_err**2))
                        * np.exp(-(h - new_h)**2 / (2 * y_err**2))
                        Z[i, j, h] = prob
                    else:
                        Z[i, j, h] = 1.0

    # Compute the likelihood P(z|x). This is the product of the prior probability
    # distribution and the sensor model, normalized by the sum over all possible
    # robot positions and directions.
    likelihood = Z * prior
    norm_factor = np.sum(likelihood)
    if norm_factor == 0:
        likelihood = np.ones_like(prior) / np.prod(prior.shape)
    else:
        likelihood = likelihood / norm_factor

    # Compute the posterior probability distribution by multiplying the likelihood
    # by the transition model, and normalizing over all possible robot positions
    # and directions.
    posterior = np.tensordot(T, likelihood, axes=((0, 1), (0, 1)))
    norm_factor = np.sum(posterior)
    if norm_factor == 0:
        posterior = np.ones_like(prior) / np.prod(prior.shape)
    else:
        posterior = posterior / norm_factor

    return posterior
